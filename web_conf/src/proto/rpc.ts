/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.28.0
 * source: rpc.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class GetAnalogSwitchStateRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        analog_switch_id?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("analog_switch_id" in data && data.analog_switch_id != undefined) {
                this.analog_switch_id = data.analog_switch_id;
            }
        }
    }
    get analog_switch_id() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set analog_switch_id(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        analog_switch_id?: number;
    }): GetAnalogSwitchStateRequest {
        const message = new GetAnalogSwitchStateRequest({});
        if (data.analog_switch_id != null) {
            message.analog_switch_id = data.analog_switch_id;
        }
        return message;
    }
    toObject() {
        const data: {
            analog_switch_id?: number;
        } = {};
        if (this.analog_switch_id != null) {
            data.analog_switch_id = this.analog_switch_id;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.analog_switch_id != 0)
            writer.writeUint32(1, this.analog_switch_id);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetAnalogSwitchStateRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetAnalogSwitchStateRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.analog_switch_id = reader.readUint32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): GetAnalogSwitchStateRequest {
        return GetAnalogSwitchStateRequest.deserialize(bytes);
    }
}
export class AnalogSwitchState extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        timestamp_us?: number;
        pressed_mm?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("timestamp_us" in data && data.timestamp_us != undefined) {
                this.timestamp_us = data.timestamp_us;
            }
            if ("pressed_mm" in data && data.pressed_mm != undefined) {
                this.pressed_mm = data.pressed_mm;
            }
        }
    }
    get timestamp_us() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set timestamp_us(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get pressed_mm() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set pressed_mm(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        timestamp_us?: number;
        pressed_mm?: number;
    }): AnalogSwitchState {
        const message = new AnalogSwitchState({});
        if (data.timestamp_us != null) {
            message.timestamp_us = data.timestamp_us;
        }
        if (data.pressed_mm != null) {
            message.pressed_mm = data.pressed_mm;
        }
        return message;
    }
    toObject() {
        const data: {
            timestamp_us?: number;
            pressed_mm?: number;
        } = {};
        if (this.timestamp_us != null) {
            data.timestamp_us = this.timestamp_us;
        }
        if (this.pressed_mm != null) {
            data.pressed_mm = this.pressed_mm;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.timestamp_us != 0)
            writer.writeUint32(1, this.timestamp_us);
        if (this.pressed_mm != 0)
            writer.writeDouble(2, this.pressed_mm);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AnalogSwitchState {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AnalogSwitchState();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.timestamp_us = reader.readUint32();
                    break;
                case 2:
                    message.pressed_mm = reader.readDouble();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): AnalogSwitchState {
        return AnalogSwitchState.deserialize(bytes);
    }
}
export class GetAnalogSwitchStateResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        states?: AnalogSwitchState[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("states" in data && data.states != undefined) {
                this.states = data.states;
            }
        }
    }
    get states() {
        return pb_1.Message.getRepeatedWrapperField(this, AnalogSwitchState, 1) as AnalogSwitchState[];
    }
    set states(value: AnalogSwitchState[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        states?: ReturnType<typeof AnalogSwitchState.prototype.toObject>[];
    }): GetAnalogSwitchStateResponse {
        const message = new GetAnalogSwitchStateResponse({});
        if (data.states != null) {
            message.states = data.states.map(item => AnalogSwitchState.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            states?: ReturnType<typeof AnalogSwitchState.prototype.toObject>[];
        } = {};
        if (this.states != null) {
            data.states = this.states.map((item: AnalogSwitchState) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.states.length)
            writer.writeRepeatedMessage(1, this.states, (item: AnalogSwitchState) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetAnalogSwitchStateResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetAnalogSwitchStateResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.states, () => pb_1.Message.addToRepeatedWrapperField(message, 1, AnalogSwitchState.deserialize(reader), AnalogSwitchState));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static override deserializeBinary(bytes: Uint8Array): GetAnalogSwitchStateResponse {
        return GetAnalogSwitchStateResponse.deserialize(bytes);
    }
}
